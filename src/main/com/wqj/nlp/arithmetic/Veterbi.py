import numpy as np


# 先验条件：
# 2、  已知情况
# 隐含的身体状况={健康，发烧}
# 可观察的感觉状态={正常、冷、头晕}
# 月儿预判的阿鲁的身体状态的概率分布={健康：0.6，发烧：0.4}
# 月儿认为的阿鲁的身体健康的转换概率分布={
# 健康->健康：0.7
# 健康->发烧：0.3
# 发烧->健康：0.4
# 发烧->发烧：0.6
# }
# 月儿认为的在相应的健康状况条件下，阿鲁的感觉的概率分布={
# 健康，正常：0.5，冷：0.4，头晕：0.1；
# 发烧，正常：0.1，冷：0.3，头晕：0.6
# }
# 已知条件
# 阿鲁连续三天的身体感觉依次是：正常、冷、头晕。


# P(今天健康) = P(正常|健康)*P(健康|初始情况) = 0.5 * 0.6 = 0.3

# P(今天发烧) = P(正常|发烧)*P(发烧|初始情况) = 0.1 * 0.4 = 0.04


# 那么第二天有四种情况，由于第一天的发烧或者健康转换到第二天的发烧或者健康。

# P(前一天发烧，今天发烧) = P(前一天发烧) * P(发烧->发烧)*P(冷 | 发烧) = 0.04 * 0.6 * 0.3 = 0.0072

# P(前一天发烧，今天健康) = P(前一天发烧) * P(发烧->健康)*P(冷 | 健康) = 0.04 * 0.4 * 0.4 = 0.0064

# P(前一天健康，今天健康) = P(前一天健康) * P(健康->健康)*P(冷 | 健康) = 0.3 * 0.7 * 0.4 = 0.084

# P(前一天健康，今天发烧) = P(前一天健康) * P(健康->发烧)*P(冷 | 发烧) = 0.3 * 0.3 * .03 = 0.027

# 那么可以认为，第二天最可能的状态是：健康。


# HMM
# 的三大问题
# （1）评估问题(概率计算问题)
# 即给定观测序列 O=O1,O2,O3…Ot和模型参数λ=(A,B,pi)，怎样有效计算这一观测序列出现的概率.
# (Forward-backward算法)
# （2）解码问题(预测问题)
# 即给定观测序列 O=O1,O2,O3…Ot和模型参数λ=(A,B,pi)，怎样寻找满足这种观察序列意义上最优的隐含状态序列S。
# (viterbi算法,近似算法)
# （3）学习问题
# 即HMM的模型参数λ=(A,B,pi)未知，如何求出这3个参数以使观测序列O=O1,O2,O3…Ot的概率尽可能的大.
# (极大似然估计的方法估计参数,Baum-Welch,EM算法)

def viterbi(trainsion_probility, emission_probility, pi, obs_seq):
    pass


if __name__ == '__main__':
    # 隐马尔可夫模型λ=(A, B, pai)
    # pai是初始状态概率分布，初始状态个数=np.shape(pai)[0]
    # 在所有数据中 来自各个盒子的占比 ，所有的想加起来等于1
    pai = np.array([[0.2],
                    [0.4],
                    [0.4]])

    # A是状态转移概率分布，状态集合Q的大小N=np.shape(A)[0]
    # 同理，统计所有样本中，在前面是盒子1在变成盒子2的次数，再除以盒子1出现的总次数，便得到由盒子1转移到盒子2的概率分布，其他可得
    # 从下给定A可知：Q={盒1, 盒2, 盒3}, N=3
    A = np.array([[0.5, 0.2, 0.3],
                  [0.3, 0.5, 0.2],
                  [0.2, 0.3, 0.5]])


    # B是观测概率分布，观测集合V的大小T=np.shape(B)[1]
    # 统计训练数据中，状态为j并观测为k的频数，除以训练数据中状态j出现的次数，其他同理可得
    # 从下面给定的B可知：V={红，白}，T=2
    B = np.array([[0.5, 0.5],
                  [0.4, 0.6],
                  [0.7, 0.3]])


    # 观测序列
    Observe = np.array([[0],
                        [1],
                        [0]])  # 0表示红色，1表示白，就是(红，白，红)观测序列

    # 通过Observe 观测序列 预测隐藏序列
    viterbi(A, B, pai, Observe)
